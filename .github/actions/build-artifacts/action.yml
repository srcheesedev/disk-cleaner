name: 'Build Release Artifacts'
description: 'Builds and packages artifacts for multiple platforms'

inputs:
  version:
    description: 'Version to build'
    required: true
  target:
    description: 'Target architecture'
    required: true
  platform:
    description: 'Platform name for artifact'
    required: true
  package-type:
    description: 'Package type to create (deb, rpm, pkg, msi, binary)'
    required: false
    default: 'binary'
  project-name:
    description: 'Project binary name'
    required: false
    default: 'disk-cleaner-rs'
  include-files:
    description: 'Additional files to include (space-separated)'
    required: false
    default: 'README.md LICENSE'
  include-scripts:
    description: 'Scripts to include on Unix platforms'
    required: false
    default: 'install.sh'

outputs:
  artifact-name:
    description: 'Name of created artifact'
    value: ${{ steps.package.outputs.artifact-name }}
  artifact-path:
    description: 'Path to created artifact'
    value: ${{ steps.package.outputs.artifact-path }}

runs:
  using: 'composite'
  steps:
    - name: Setup Rust environment
      uses: ./.github/actions/setup-rust
      with:
        targets: ${{ inputs.target }}
        cache-key-suffix: 'release-${{ inputs.platform }}'

    - name: Build release binary
      shell: bash
      run: |
        echo "ðŸ—ï¸ Building for target: ${{ inputs.target }}"
        cargo build --release --target ${{ inputs.target }}
        echo "âœ… Build completed"

    - name: Package artifacts
      id: package
      shell: bash
      run: |
        mkdir -p dist packages
        
        # Determine file extension and binary path
        if [[ "${{ runner.os }}" == "Windows" ]]; then
          SUFFIX=".exe"
        else
          SUFFIX=""
        fi
        
        # Find the binary - try multiple possible names
        BINARY_PATH=""
        TARGET_DIR="target/${{ inputs.target }}/release"
        
        # Try different possible binary names (prefer clean name first)
        for binary_name in "disk-cleaner" "${{ inputs.project-name }}" "disk-cleaner-rs"; do
          if [ -f "$TARGET_DIR/${binary_name}${SUFFIX}" ]; then
            BINARY_PATH="$TARGET_DIR/${binary_name}${SUFFIX}"
            BINARY_NAME="${binary_name}${SUFFIX}"
            echo "ðŸ“¦ Found binary: $BINARY_PATH"
            break
          fi
        done
        
        # If no binary found, list available files for debugging
        if [ -z "$BINARY_PATH" ]; then
          echo "âŒ No binary found. Available files in $TARGET_DIR:"
          ls -la "$TARGET_DIR/" || echo "Directory not found"
          echo "Searching for any executable files:"
          find "$TARGET_DIR/" -type f -perm +111 2>/dev/null || echo "No executable files found"
          exit 1
        fi
        
        # Copy binary to dist
        cp "$BINARY_PATH" "dist/$BINARY_NAME"
        echo "ðŸ“¦ Copied binary: $BINARY_NAME"
        
        # Copy additional files
        for file in ${{ inputs.include-files }}; do
          if [ -f "$file" ]; then
            cp "$file" dist/
            echo "ðŸ“„ Included: $file"
          fi
        done
        
        # Create packages based on package-type
        echo "ðŸ“¦ Creating package type: ${{ inputs.package-type }}"
        ARTIFACT_NAME="${{ inputs.project-name }}-${{ inputs.platform }}"
        
        case "${{ inputs.package-type }}" in
          "binary")
            # Basic binary archives
            if [[ "${{ runner.os }}" == "Windows" ]]; then
              cd dist && 7z a "../packages/${ARTIFACT_NAME}.zip" *
              ARTIFACT_PATH="packages/${ARTIFACT_NAME}.zip"
            else
              cd dist && tar -czf "../packages/${ARTIFACT_NAME}.tar.gz" *
              ARTIFACT_PATH="packages/${ARTIFACT_NAME}.tar.gz"
            fi
            ;;
            
          "deb")
            # Create Debian package
            echo "ðŸ§ Creating DEB package..."
            PACKAGE_NAME="disk-cleaner"
            VERSION="${{ inputs.version }}"
            DEB_DIR="packages/deb"
            
            mkdir -p "$DEB_DIR/DEBIAN"
            mkdir -p "$DEB_DIR/usr/local/bin"
            mkdir -p "$DEB_DIR/usr/share/doc/$PACKAGE_NAME"
            
            # Copy binary
            cp "dist/$BINARY_NAME" "$DEB_DIR/usr/local/bin/disk-cleaner"
            chmod +x "$DEB_DIR/usr/local/bin/disk-cleaner"
            
            # Copy documentation
            cp dist/README.md "$DEB_DIR/usr/share/doc/$PACKAGE_NAME/" 2>/dev/null || true
            cp dist/LICENSE "$DEB_DIR/usr/share/doc/$PACKAGE_NAME/" 2>/dev/null || true
            
            # Create control file
            cat > "$DEB_DIR/DEBIAN/control" << EOF
            Package: $PACKAGE_NAME
            Version: $VERSION
            Section: utils
            Priority: optional
            Architecture: amd64
            Maintainer: srcheesedev <noreply@github.com>
            Description: Lightning-fast disk space analyzer and cleanup tool
             A high-performance cross-platform disk analyzer and cleaner built with Rust.
             Provides fast directory scanning, file analysis, and safe cleanup operations.
            EOF
            
            # Build DEB package
            dpkg-deb --build "$DEB_DIR" "packages/${PACKAGE_NAME}_${VERSION}_amd64.deb"
            ARTIFACT_PATH="packages/${PACKAGE_NAME}_${VERSION}_amd64.deb"
            ;;
            
          "rpm")
            # Create RPM package
            echo "ðŸ“¦ Creating RPM package..."
            PACKAGE_NAME="disk-cleaner"
            VERSION="${{ inputs.version }}"
            
            # Install rpmbuild if not available
            if ! command -v rpmbuild &> /dev/null; then
              sudo apt-get update
              sudo apt-get install -y rpm
            fi
            
            # Create RPM structure
            RPM_ROOT="packages/rpm"
            mkdir -p "$RPM_ROOT"/{BUILD,RPMS,SOURCES,SPECS,SRPMS}
            mkdir -p "$RPM_ROOT/BUILD/usr/local/bin"
            mkdir -p "$RPM_ROOT/BUILD/usr/share/doc/$PACKAGE_NAME"
            
            # Copy files
            cp "dist/$BINARY_NAME" "$RPM_ROOT/BUILD/usr/local/bin/disk-cleaner"
            chmod +x "$RPM_ROOT/BUILD/usr/local/bin/disk-cleaner"
            cp dist/README.md "$RPM_ROOT/BUILD/usr/share/doc/$PACKAGE_NAME/" 2>/dev/null || true
            cp dist/LICENSE "$RPM_ROOT/BUILD/usr/share/doc/$PACKAGE_NAME/" 2>/dev/null || true
            
            # Create spec file
            cat > "$RPM_ROOT/SPECS/$PACKAGE_NAME.spec" << EOF
            Name: $PACKAGE_NAME
            Version: $VERSION
            Release: 1
            Summary: Lightning-fast disk space analyzer and cleanup tool
            License: MIT
            Group: Applications/System
            BuildArch: x86_64
            
            %description
            A high-performance cross-platform disk analyzer and cleaner built with Rust.
            Provides fast directory scanning, file analysis, and safe cleanup operations.
            
            %files
            /usr/local/bin/disk-cleaner
            /usr/share/doc/$PACKAGE_NAME/README.md
            /usr/share/doc/$PACKAGE_NAME/LICENSE
            
            %changelog
            * $(date '+%a %b %d %Y') srcheesedev <noreply@github.com> - $VERSION-1
            - Release $VERSION
            EOF
            
            # Build RPM
            cd "$RPM_ROOT"
            rpmbuild --define "_topdir $(pwd)" --define "_rpmdir $(pwd)/RPMS" -bb "SPECS/$PACKAGE_NAME.spec"
            cp "RPMS/x86_64/$PACKAGE_NAME-$VERSION-1.x86_64.rpm" "../$PACKAGE_NAME-$VERSION-1.x86_64.rpm"
            cd ../..
            ARTIFACT_PATH="packages/$PACKAGE_NAME-$VERSION-1.x86_64.rpm"
            ;;
            
          "pkg")
            # Create macOS PKG
            echo "ðŸŽ Creating PKG package..."
            PACKAGE_NAME="disk-cleaner"
            VERSION="${{ inputs.version }}"
            PKG_ROOT="packages/pkg"
            
            mkdir -p "$PKG_ROOT/usr/local/bin"
            cp "dist/$BINARY_NAME" "$PKG_ROOT/usr/local/bin/disk-cleaner"
            chmod +x "$PKG_ROOT/usr/local/bin/disk-cleaner"
            
            # Build PKG
            pkgbuild --root "$PKG_ROOT" \
                     --identifier "com.srcheesedev.disk-cleaner" \
                     --version "$VERSION" \
                     "packages/$PACKAGE_NAME-macos-v$VERSION.pkg"
            ARTIFACT_PATH="packages/$PACKAGE_NAME-macos-v$VERSION.pkg"
            ;;
            
          "msi")
            # Create Windows MSI
            echo "ðŸªŸ Creating MSI package..."
            PACKAGE_NAME="disk-cleaner"
            VERSION="${{ inputs.version }}"
            
            # For now, create a ZIP as MSI creation requires WiX toolset
            # TODO: Implement proper MSI creation with WiX
            cd dist && 7z a "../packages/$PACKAGE_NAME-windows-v$VERSION.zip" *
            ARTIFACT_PATH="packages/$PACKAGE_NAME-windows-v$VERSION.zip"
            echo "âš ï¸  MSI creation not yet implemented, created ZIP instead"
            ;;
            
          *)
            echo "âŒ Unknown package type: ${{ inputs.package-type }}"
            exit 1
            ;;
        esac
        
        echo "ðŸ“¦ Created package: $ARTIFACT_PATH"
        
        # Set outputs
        echo "artifact-name=$ARTIFACT_NAME" >> $GITHUB_OUTPUT
        echo "artifact-path=$ARTIFACT_PATH" >> $GITHUB_OUTPUT

    - name: Upload artifact
      uses: actions/upload-artifact@v4
      with:
        name: ${{ steps.package.outputs.artifact-name }}
        path: ${{ steps.package.outputs.artifact-path }}
        if-no-files-found: error