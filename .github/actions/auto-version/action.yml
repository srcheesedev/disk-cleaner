name: 'Automatic Semantic Versioning'
description: 'Analyzes commits, bumps version, creates tag'

inputs:
  base-branch:
    description: 'Base branch to compare against'
    required: false
    default: 'main'
  head-branch:
    description: 'Head branch to analyze'
    required: false
    default: 'develop'
  version-file:
    description: 'File containing version (Cargo.toml, package.json, etc)'
    required: false
    default: 'Cargo.toml'
  version-pattern:
    description: 'Regex pattern to find version'
    required: false
    default: '^version = "([0-9]+\.[0-9]+\.[0-9]+)"'
  token:
    description: 'GitHub token for operations'
    required: true

outputs:
  old-version:
    description: 'Previous version'
    value: ${{ steps.version-info.outputs.old-version }}
  new-version:
    description: 'New calculated version'
    value: ${{ steps.version-info.outputs.new-version }}
  version-created:
    description: 'Whether new version was created'
    value: ${{ steps.version-info.outputs.created }}
  bump-type:
    description: 'Type of version bump (major/minor/patch)'
    value: ${{ steps.analyze.outputs.bump-type }}

runs:
  using: 'composite'
  steps:
    - name: Setup Git configuration
      uses: ./.github/actions/setup-git
      
    - name: Fetch and setup branches
      shell: bash
      run: |
        echo "🔄 Fetching latest changes..."
        git fetch origin
        
        BASE_BRANCH="${{ inputs.base-branch }}"
        HEAD_BRANCH="${{ inputs.head-branch }}"
        
        echo "🌿 Setting up branches: $BASE_BRANCH and $HEAD_BRANCH"
        git checkout "$HEAD_BRANCH" || git checkout -b "$HEAD_BRANCH" "origin/$HEAD_BRANCH"
        
    - name: Get current version
      id: current-version
      shell: bash
      run: |
        VERSION_FILE="${{ inputs.version-file }}"
        if [ "$VERSION_FILE" = "Cargo.toml" ]; then
          CURRENT=$(grep '^version = ' Cargo.toml | head -1 | cut -d'"' -f2)
        elif [ "$VERSION_FILE" = "package.json" ]; then
          CURRENT=$(grep '"version":' package.json | cut -d'"' -f4)
        else
          PATTERN='${{ inputs.version-pattern }}'
          CURRENT=$(grep -E "$PATTERN" "$VERSION_FILE" | sed -E 's/.*"([0-9]+\.[0-9]+\.[0-9]+)".*/\1/')
        fi
        echo "current=$CURRENT" >> $GITHUB_OUTPUT
        echo "📦 Current version: $CURRENT"

    - name: Analyze commits for version bump
      id: analyze
      shell: bash
      run: |
        BASE_BRANCH="${{ inputs.base-branch }}"
        HEAD_BRANCH="${{ inputs.head-branch }}"
        echo "🔍 Analyzing commits between $BASE_BRANCH and $HEAD_BRANCH..."
        
        # Get commits that are in head but not in base
        COMMITS=$(git log "origin/$BASE_BRANCH..origin/$HEAD_BRANCH" --pretty=format:"%s" --no-merges)
        
        echo "📝 Commits to analyze:"
        echo "$COMMITS"
        
        # Determine version bump based on conventional commits
        BUMP_TYPE="patch"
        
        # Check for breaking changes (major)
        if echo "$COMMITS" | grep -qE "(feat|fix|refactor|perf)(\(.+\))?!:|BREAKING CHANGE"; then
          BUMP_TYPE="major"
          echo "🚨 MAJOR bump detected (breaking changes)"
        # Check for new features (minor)  
        elif echo "$COMMITS" | grep -qE "^feat(\(.+\))?:"; then
          BUMP_TYPE="minor"
          echo "✨ MINOR bump detected (new features)"
        # Default to patch for fixes, docs, etc.
        else
          echo "🔧 PATCH bump detected (fixes/improvements)"
        fi
        
        echo "bump-type=$BUMP_TYPE" >> $GITHUB_OUTPUT

    - name: Calculate and apply new version
      id: version-info
      shell: bash
      run: |
        CURRENT="${{ steps.current-version.outputs.current }}"
        BUMP="${{ steps.analyze.outputs.bump-type }}"
        
        echo "📊 Current: $CURRENT, Bump: $BUMP"
        
        # Parse semantic version using simple string operations
        IFS='.' read -ra VERSION_PARTS <<< "$CURRENT"
        MAJOR="${VERSION_PARTS[0]}"
        MINOR="${VERSION_PARTS[1]}"  
        PATCH="${VERSION_PARTS[2]}"
        
        # Validate we have a proper version
        if [ -z "$MAJOR" ] || [ -z "$MINOR" ] || [ -z "$PATCH" ]; then
          echo "❌ Invalid version format: $CURRENT"
          exit 1
        fi
        
        # Bump version according to type
        case $BUMP in
          major)
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
            ;;
          minor)
            MINOR=$((MINOR + 1))
            PATCH=0
            ;;
          patch)
            PATCH=$((PATCH + 1))
            ;;
        esac
        
        NEW_VERSION="$MAJOR.$MINOR.$PATCH"
        echo "🎯 New version: $NEW_VERSION"
        
        # Update version in file
        VERSION_FILE="${{ inputs.version-file }}"
        if [ "$VERSION_FILE" = "Cargo.toml" ]; then
          sed -i.bak "s/^version = \".*\"/version = \"$NEW_VERSION\"/" Cargo.toml
        elif [ "$VERSION_FILE" = "package.json" ]; then
          sed -i.bak "s/\"version\": *\"[^\"]*\"/\"version\": \"$NEW_VERSION\"/" package.json
        fi
        
        echo "✅ Updated $VERSION_FILE to version $NEW_VERSION"
        
        # Ensure we're on the correct branch for pushing
        HEAD_BRANCH="${{ inputs.head-branch }}"
        echo "🔀 Ensuring we're on branch $HEAD_BRANCH"
        git checkout "$HEAD_BRANCH" || git checkout -b "$HEAD_BRANCH"
        
        # Create git tag
        git add "$VERSION_FILE"
        git commit -m "chore: bump version to $NEW_VERSION"
        git tag "v$NEW_VERSION"
        echo "🏷️ Created tag v$NEW_VERSION"
        
        # Push changes
        git push origin "$HEAD_BRANCH"
        git push origin "v$NEW_VERSION"
        echo "✅ Pushed version and tag"
        
        # Set outputs
        echo "old-version=$CURRENT" >> $GITHUB_OUTPUT
        echo "new-version=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "created=true" >> $GITHUB_OUTPUT