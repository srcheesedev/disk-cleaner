name: 'Automatic Semantic Versioning'
description: 'Analyzes commits, bumps version, creates tag'

inputs:
  base-branch:
    description: 'Base branch to compare against'
    required: false
    default: 'main'
  head-branch:
    description: 'Head branch to analyze'
    required: false
    default: 'develop'
  version-file:
    description: 'File containing version (Cargo.toml, package.json, etc)'
    required: false
    default: 'Cargo.toml'
  version-pattern:
    description: 'Regex pattern to find version'
    required: false
    default: '^version = "([0-9]+\.[0-9]+\.[0-9]+)"'
  token:
    description: 'GitHub token for operations'
    required: true

outputs:
  old-version:
    description: 'Previous version'
    value: ${{ steps.version-info.outputs.old-version }}
  new-version:
    description: 'New calculated version'
    value: ${{ steps.version-info.outputs.new-version }}
  version-created:
    description: 'Whether new version was created'
    value: ${{ steps.version-info.outputs.created }}
  bump-type:
    description: 'Type of version bump (major/minor/patch)'
    value: ${{ steps.analyze.outputs.bump-type }}

runs:
  using: 'composite'
  steps:
    - name: Setup Git configuration
      uses: ./.github/actions/setup-git
      
    - name: Get current version
      id: current-version
      shell: bash
      run: |
        VERSION_FILE="${{ inputs.version-file }}"
        if [ "$VERSION_FILE" = "Cargo.toml" ]; then
          CURRENT=$(grep '^version = ' Cargo.toml | head -1 | cut -d'"' -f2)
        elif [ "$VERSION_FILE" = "package.json" ]; then
          CURRENT=$(grep '"version":' package.json | cut -d'"' -f4)
        else
          PATTERN="${{ inputs.version-pattern }}"
          CURRENT=$(grep -E "$PATTERN" "$VERSION_FILE" | sed -E "s|$PATTERN|\1|")
        fi
        echo "current=$CURRENT" >> $GITHUB_OUTPUT
        echo "ðŸ“¦ Current version: $CURRENT"

    - name: Analyze commits for version bump
      id: analyze
      shell: bash
      run: |
        BASE_BRANCH="${{ inputs.base-branch }}"
        HEAD_BRANCH="${{ inputs.head-branch }}"
        echo "ðŸ” Analyzing commits between $BASE_BRANCH and $HEAD_BRANCH..."
        
        # Get commits that are in head but not in base
        COMMITS=$(git log "origin/$BASE_BRANCH..origin/$HEAD_BRANCH" --pretty=format:"%s" --no-merges)
        
        echo "ðŸ“ Commits to analyze:"
        echo "$COMMITS"
        
        # Determine version bump based on conventional commits
        BUMP_TYPE="patch"
        
        # Check for breaking changes (major)
        if echo "$COMMITS" | grep -qE "(feat|fix|refactor|perf)(\(.+\))?!:|BREAKING CHANGE"; then
          BUMP_TYPE="major"
          echo "ðŸš¨ MAJOR bump detected (breaking changes)"
        # Check for new features (minor)  
        elif echo "$COMMITS" | grep -qE "^feat(\(.+\))?:"; then
          BUMP_TYPE="minor"
          echo "âœ¨ MINOR bump detected (new features)"
        # Default to patch for fixes, docs, etc.
        else
          echo "ðŸ”§ PATCH bump detected (fixes/improvements)"
        fi
        
        echo "bump-type=$BUMP_TYPE" >> $GITHUB_OUTPUT

    - name: Calculate and apply new version
      id: version-info
      shell: bash
      run: |
        CURRENT="${{ steps.current-version.outputs.current }}"
        BUMP="${{ steps.analyze.outputs.bump-type }}"
        
        echo "ðŸ“Š Current: $CURRENT, Bump: $BUMP"
        
        # Parse semantic version
        if [[ $CURRENT =~ ^([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
          MAJOR=${BASH_REMATCH[1]}
          MINOR=${BASH_REMATCH[2]}
          PATCH=${BASH_REMATCH[3]}
        else
          echo "âŒ Invalid version format: $CURRENT"
          exit 1
        fi
        
        # Bump version according to type
        case $BUMP in
          major)
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
            ;;
          minor)
            MINOR=$((MINOR + 1))
            PATCH=0
            ;;
          patch)
            PATCH=$((PATCH + 1))
            ;;
        esac
        
        NEW_VERSION="$MAJOR.$MINOR.$PATCH"
        echo "ðŸŽ¯ New version: $NEW_VERSION"
        
        # Update version in file
        VERSION_FILE="${{ inputs.version-file }}"
        if [ "$VERSION_FILE" = "Cargo.toml" ]; then
          sed -i "s/^version = \".*\"/version = \"$NEW_VERSION\"/" Cargo.toml
        elif [ "$VERSION_FILE" = "package.json" ]; then
          sed -i "s/\"version\": *\"[^\"]*\"/\"version\": \"$NEW_VERSION\"/" package.json
        fi
        
        echo "âœ… Updated $VERSION_FILE to version $NEW_VERSION"
        
        # Create git tag
        VERSION_FILE="${{ inputs.version-file }}"
        git add "$VERSION_FILE"
        git commit -m "chore: bump version to $NEW_VERSION"
        git tag "v$NEW_VERSION"
        echo "ðŸ·ï¸ Created tag v$NEW_VERSION"
        
        # Push changes
        HEAD_BRANCH="${{ inputs.head-branch }}"
        git push origin "$HEAD_BRANCH"
        git push origin "v$NEW_VERSION"
        echo "âœ… Pushed version and tag"
        
        # Set outputs
        echo "old-version=$CURRENT" >> $GITHUB_OUTPUT
        echo "new-version=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "created=true" >> $GITHUB_OUTPUT