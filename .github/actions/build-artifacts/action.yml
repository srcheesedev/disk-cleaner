name: 'Build Release Artifacts'
description: 'Builds and packages artifacts for multiple platforms'

inputs:
  version:
    description: 'Version to build'
    required: true
  target:
    description: 'Target architecture'
    required: true
  platform:
    description: 'Platform name for artifact'
    required: true
  package-type:
    description: 'Package type to create (deb, rpm, pkg, msi, binary)'
    required: false
    default: 'binary'
  project-name:
    description: 'Project binary name'
    required: false
    default: 'disk-cleaner-rs'
  include-files:
    description: 'Additional files to include (space-separated)'
    required: false
    default: 'README.md LICENSE'
  include-scripts:
    description: 'Scripts to include on Unix platforms'
    required: false
    default: 'install.sh'

outputs:
  artifact-name:
    description: 'Name of created artifact'
    value: ${{ steps.package.outputs.artifact-name }}
  artifact-path:
    description: 'Path to created artifact'
    value: ${{ steps.package.outputs.artifact-path }}

runs:
  using: 'composite'
  steps:
    - name: Setup Rust environment
      uses: ./.github/actions/setup-rust
      with:
        targets: ${{ inputs.target }}
        cache-key-suffix: 'release-${{ inputs.platform }}'

    - name: Build release binary
      shell: bash
      run: |
        echo "ðŸ—ï¸ Building for target: ${{ inputs.target }}"
        cargo build --release --target ${{ inputs.target }}
        echo "âœ… Build completed"

    - name: Package artifacts
      id: package
      shell: bash
      run: |
        mkdir -p dist packages
        
        # Determine file extension and binary path
        if [[ "${{ runner.os }}" == "Windows" ]]; then
          SUFFIX=".exe"
        else
          SUFFIX=""
        fi
        
        # Find the binary - try multiple possible names
        BINARY_PATH=""
        TARGET_DIR="target/${{ inputs.target }}/release"
        
        # Try different possible binary names (prefer clean name first)
        for binary_name in "disk-cleaner" "${{ inputs.project-name }}" "disk-cleaner-rs"; do
          if [ -f "$TARGET_DIR/${binary_name}${SUFFIX}" ]; then
            BINARY_PATH="$TARGET_DIR/${binary_name}${SUFFIX}"
            BINARY_NAME="${binary_name}${SUFFIX}"
            echo "ðŸ“¦ Found binary: $BINARY_PATH"
            break
          fi
        done
        
        # If no binary found, list available files for debugging
        if [ -z "$BINARY_PATH" ]; then
          echo "âŒ No binary found. Available files in $TARGET_DIR:"
          ls -la "$TARGET_DIR/" || echo "Directory not found"
          echo "Searching for any executable files:"
          find "$TARGET_DIR/" -type f -perm +111 2>/dev/null || echo "No executable files found"
          exit 1
        fi
        
        # Copy binary to dist
        cp "$BINARY_PATH" "dist/$BINARY_NAME"
        echo "ðŸ“¦ Copied binary: $BINARY_NAME"
        
        # Copy additional files
        for file in ${{ inputs.include-files }}; do
          if [ -f "$file" ]; then
            cp "$file" dist/
            echo "ðŸ“„ Included: $file"
          fi
        done
        
        # For now, only create basic binary archives
        # TODO: Implement full package creation (DEB, RPM, PKG, MSI)
        echo "ðŸ“¦ Creating binary archive..."
        ARTIFACT_NAME="${{ inputs.project-name }}-${{ inputs.platform }}"
        
        if [[ "${{ runner.os }}" == "Windows" ]]; then
          cd dist && 7z a "../packages/${ARTIFACT_NAME}.zip" *
          ARTIFACT_PATH="packages/${ARTIFACT_NAME}.zip"
        else
          cd dist && tar -czf "../packages/${ARTIFACT_NAME}.tar.gz" *
          ARTIFACT_PATH="packages/${ARTIFACT_NAME}.tar.gz"
        fi
        
        echo "ðŸ“¦ Created package: $ARTIFACT_PATH"
        
        # Set outputs
        echo "artifact-name=$ARTIFACT_NAME" >> $GITHUB_OUTPUT
        echo "artifact-path=$ARTIFACT_PATH" >> $GITHUB_OUTPUT

    - name: Upload artifact
      uses: actions/upload-artifact@v4
      with:
        name: ${{ steps.package.outputs.artifact-name }}
        path: ${{ steps.package.outputs.artifact-path }}
        if-no-files-found: error